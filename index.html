<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TypeFarm</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        :root {
            --bg-dark: #0a0a0f;
            --bg-panel: #12121a;
            --bg-input: #1a1a25;
            --text-primary: #e8e8e8;
            --text-dim: #555;
            --text-predict: #3a3a4a;
            --accent-cyan: #00d9ff;
            --accent-green: #00ff88;
            --accent-yellow: #ffd700;
            --accent-red: #ff4757;
            --accent-pink: #ff9ff3;
            --border: #2a2a3a;
        }

        body {
            font-family: 'Courier New', monospace;
            background: var(--bg-dark);
            color: var(--text-primary);
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .header {
            background: var(--bg-panel);
            border-bottom: 1px solid var(--border);
            padding: 0.6rem 1.5rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .header h1 {
            font-size: 1.3rem;
            background: linear-gradient(90deg, var(--accent-cyan), var(--accent-green));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .stats {
            display: flex;
            gap: 1.2rem;
            font-size: 0.85rem;
        }

        .stat span { color: var(--accent-yellow); }

        /* Three Lane Layout */
        .lanes {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        .lane {
            display: flex;
            flex-direction: column;
            border-right: 1px solid var(--border);
            overflow: hidden;
        }

        .lane:last-child { border-right: none; }

        .lane-actions { width: 25%; }
        .lane-commands { width: 25%; }
        .lane-game { width: 50%; }

        .lane-header {
            padding: 0.4rem 0.8rem;
            background: var(--bg-input);
            border-bottom: 1px solid var(--border);
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .lane-actions .lane-header { color: var(--accent-cyan); }
        .lane-commands .lane-header { color: var(--accent-pink); }
        .lane-game .lane-header { color: var(--accent-green); }

        .lane-content {
            flex: 1;
            overflow-y: auto;
            padding: 0.6rem;
            font-size: 0.8rem;
            line-height: 1.5;
        }

        .lane-game .lane-content {
            white-space: pre-wrap;
            font-size: 0.85rem;
        }

        /* Log Entries */
        .log-entry {
            margin-bottom: 0.3rem;
            padding: 0.2rem 0;
        }

        .log-system { color: var(--accent-cyan); }
        .log-success { color: var(--accent-green); }
        .log-warning { color: var(--accent-yellow); }
        .log-error { color: var(--accent-red); }
        .log-npc { color: var(--accent-pink); }

        /* Command Log */
        .cmd-entry {
            margin-bottom: 0.3rem;
            padding: 0.2rem 0.4rem;
            border-radius: 3px;
        }

        .cmd-valid {
            color: var(--accent-green);
            background: rgba(0, 255, 136, 0.05);
        }

        .cmd-invalid {
            color: var(--accent-red);
            background: rgba(255, 71, 87, 0.1);
        }

        .cmd-typing {
            color: var(--accent-yellow);
            background: rgba(255, 215, 0, 0.05);
        }

        .cmd-prefix {
            color: var(--text-dim);
            margin-right: 0.3rem;
        }

        /* Terminal Input */
        .terminal-bar {
            background: var(--bg-panel);
            border-top: 1px solid var(--border);
            padding: 0.6rem 1rem;
        }

        .input-wrapper {
            position: relative;
            display: flex;
            align-items: center;
            background: var(--bg-input);
            border: 1px solid var(--border);
            border-radius: 4px;
            padding: 0.5rem 0.8rem;
        }

        .input-wrapper:focus-within {
            border-color: var(--accent-cyan);
        }

        .terminal-prompt {
            color: var(--accent-green);
            margin-right: 0.5rem;
        }

        .input-container {
            position: relative;
            flex: 1;
        }

        .terminal-input {
            width: 100%;
            background: transparent;
            border: none;
            font-family: inherit;
            font-size: 1rem;
            color: var(--text-primary);
            outline: none;
            position: relative;
            z-index: 2;
        }

        .prediction-overlay {
            position: absolute;
            top: 0;
            left: 0;
            font-size: 1rem;
            color: var(--text-predict);
            pointer-events: none;
            z-index: 1;
            white-space: pre;
        }

        .prediction-typed {
            color: transparent;
        }

        .prediction-suggest {
            color: var(--text-predict);
        }

        /* Scrollbar */
        ::-webkit-scrollbar { width: 5px; }
        ::-webkit-scrollbar-track { background: var(--bg-dark); }
        ::-webkit-scrollbar-thumb { background: var(--border); border-radius: 3px; }

        /* Game Display */
        .section-title { color: var(--accent-cyan); margin-bottom: 0.5rem; }
        .highlight { color: var(--accent-yellow); }
        .dim { color: var(--text-dim); }
        .green { color: var(--accent-green); }
        .red { color: var(--accent-red); }
        .pink { color: var(--accent-pink); }

        .typing-area {
            background: var(--bg-input);
            border: 1px solid var(--border);
            padding: 0.8rem;
            margin: 0.8rem 0;
            border-radius: 4px;
            font-size: 1rem;
            line-height: 1.7;
        }

        .correct { color: var(--accent-green); }
        .incorrect { color: var(--accent-red); background: rgba(255,71,87,0.2); text-decoration: line-through; }
        .cursor { border-left: 2px solid var(--accent-cyan); animation: blink 1s infinite; }
        .pending { color: var(--text-dim); }

        @keyframes blink { 50% { border-color: transparent; } }
    </style>
</head>
<body>
    <header class="header">
        <h1>üå± TypeFarm</h1>
        <div class="stats">
            <div>üí∞ <span id="coins">50</span></div>
            <div>‚≠ê Lv.<span id="level">1</span></div>
            <div>‚å®Ô∏è <span id="wpm">0</span> WPM</div>
            <div>üéØ <span id="accuracy">100</span>%</div>
        </div>
    </header>

    <main class="lanes">
        <aside class="lane lane-actions">
            <div class="lane-header">üì° Actions</div>
            <div class="lane-content" id="actions-log"></div>
        </aside>

        <aside class="lane lane-commands">
            <div class="lane-header">üìù Command Log</div>
            <div class="lane-content" id="command-log"></div>
        </aside>

        <section class="lane lane-game">
            <div class="lane-header">üéÆ Game</div>
            <div class="lane-content" id="display"></div>
        </section>
    </main>

    <footer class="terminal-bar">
        <div class="input-wrapper">
            <span class="terminal-prompt">$</span>
            <div class="input-container">
                <div class="prediction-overlay" id="prediction"></div>
                <input type="text" class="terminal-input" id="input" autocomplete="off" autofocus>
            </div>
        </div>
    </footer>

    <script>
        // ==================== GAME STATE ====================
        const state = {
            coins: 50,
            level: 1,
            xp: 0,
            totalKeystrokes: 0,
            correctKeystrokes: 0,
            incorrectKeystrokes: 0,
            startTime: null,
            mode: 'normal',
            typingText: '',
            typingIndex: 0,
            typingErrors: [],
            inventory: {},
            farm: Array(9).fill(null),
            commandHistory: [],
            shopItems: {
                'carrot seeds': { price: 10, desc: 'Grows 30s, sells 25' },
                'tomato seeds': { price: 20, desc: 'Grows 45s, sells 50' },
                'corn seeds': { price: 35, desc: 'Grows 60s, sells 80' },
                'pumpkin seeds': { price: 50, desc: 'Grows 90s, sells 120' },
                'golden seeds': { price: 150, desc: 'Grows 120s, sells 400' },
                'fertilizer': { price: 25, desc: 'Halves grow time' },
                'watering can': { price: 100, desc: 'Auto-water crops' }
            },
            crops: {
                'carrot seeds': { growTime: 30, emoji: 'ü•ï', sellPrice: 25, stages: ['üå±', 'üåø', 'ü•ï'] },
                'tomato seeds': { growTime: 45, emoji: 'üçÖ', sellPrice: 50, stages: ['üå±', 'üåø', 'üçÖ'] },
                'corn seeds': { growTime: 60, emoji: 'üåΩ', sellPrice: 80, stages: ['üå±', 'üåæ', 'üåΩ'] },
                'pumpkin seeds': { growTime: 90, emoji: 'üéÉ', sellPrice: 120, stages: ['üå±', 'üåø', 'üéÉ'] },
                'golden seeds': { growTime: 120, emoji: '‚ú®', sellPrice: 400, stages: ['üå±', 'üí´', '‚ú®'] }
            },
            prompts: [
                "The quick brown fox jumps over the lazy dog.",
                "Pack my box with five dozen liquor jugs.",
                "Farmers plant seeds in fertile soil every spring.",
                "The harvest moon rises over golden wheat fields.",
                "Water your crops daily for the best results.",
                "Typing faster earns more coins for your farm.",
                "Buy seeds from the shop and watch them grow.",
                "A good farmer knows patience is a virtue.",
                "The scarecrow guards the field from hungry crows.",
                "Fresh vegetables taste better from your own garden."
            ]
        };

        const plotNames = ['A1', 'A2', 'A3', 'B1', 'B2', 'B3', 'C1', 'C2', 'C3'];

        // Command predictions
        const allCommands = [
            'help', 'type', 'exit', 'shop', 'shop buy carrot seeds', 'shop buy tomato seeds',
            'shop buy corn seeds', 'shop buy pumpkin seeds', 'shop buy golden seeds',
            'shop buy fertilizer', 'shop buy watering can', 'shop sell',
            'farm', 'farm plant carrot', 'farm plant tomato', 'farm plant corn',
            'farm plant pumpkin', 'farm plant golden',
            'farm water A1', 'farm water A2', 'farm water A3',
            'farm water B1', 'farm water B2', 'farm water B3',
            'farm water C1', 'farm water C2', 'farm water C3',
            'farm harvest A1', 'farm harvest A2', 'farm harvest A3',
            'farm harvest B1', 'farm harvest B2', 'farm harvest B3',
            'farm harvest C1', 'farm harvest C2', 'farm harvest C3',
            'farm fertilize A1', 'farm fertilize A2', 'farm fertilize A3',
            'farm fertilize B1', 'farm fertilize B2', 'farm fertilize B3',
            'farm fertilize C1', 'farm fertilize C2', 'farm fertilize C3',
            'inventory', 'inv', 'stats', 'clear', 'save'
        ];

        // ==================== UTILITIES ====================
        function save() { localStorage.setItem('typefarm', JSON.stringify(state)); }

        function load() {
            const saved = localStorage.getItem('typefarm');
            if (saved) Object.assign(state, JSON.parse(saved));
        }

        function action(msg, type = 'system') {
            const el = document.getElementById('actions-log');
            const entry = document.createElement('div');
            entry.className = `log-entry log-${type}`;
            entry.textContent = msg;
            el.appendChild(entry);
            el.scrollTop = el.scrollHeight;
        }

        function logCommand(cmd, valid) {
            const el = document.getElementById('command-log');
            const entry = document.createElement('div');
            entry.className = `cmd-entry ${valid ? 'cmd-valid' : 'cmd-invalid'}`;
            entry.innerHTML = `<span class="cmd-prefix">$</span>${cmd}`;
            el.appendChild(entry);
            el.scrollTop = el.scrollHeight;
            state.commandHistory.push({ cmd, valid, time: Date.now() });
        }

        function logTypingError(expected, got) {
            const el = document.getElementById('command-log');
            const entry = document.createElement('div');
            entry.className = 'cmd-entry cmd-invalid';
            entry.innerHTML = `<span class="cmd-prefix">‚å®</span>Expected '${expected}' got '${got}'`;
            el.appendChild(entry);
            el.scrollTop = el.scrollHeight;
        }

        function display(content) {
            document.getElementById('display').innerHTML = content;
        }

        function updateStats() {
            document.getElementById('coins').textContent = state.coins;
            document.getElementById('level').textContent = state.level;
            if (state.totalKeystrokes > 0) {
                const acc = Math.round((state.correctKeystrokes / state.totalKeystrokes) * 100);
                document.getElementById('accuracy').textContent = acc;
            }
            if (state.startTime && state.correctKeystrokes > 0) {
                const mins = (Date.now() - state.startTime) / 60000;
                document.getElementById('wpm').textContent = Math.round((state.correctKeystrokes / 5) / mins);
            }
        }

        function addCoins(n) {
            state.coins += n;
            state.xp += n;
            if (state.xp >= state.level * 100) {
                state.level++;
                action(`üéâ LEVEL UP! Now level ${state.level}!`, 'success');
            }
            updateStats();
            save();
        }

        function getPlotIndex(name) {
            return plotNames.indexOf(name.toUpperCase());
        }

        // ==================== PREDICTION ====================
        function updatePrediction(input) {
            const val = input.toLowerCase();
            if (!val || state.mode === 'typing') {
                document.getElementById('prediction').innerHTML = '';
                return;
            }

            // Find best matching command
            let bestMatch = '';
            for (const cmd of allCommands) {
                if (cmd.startsWith(val) && cmd.length > val.length) {
                    bestMatch = cmd;
                    break;
                }
            }

            if (bestMatch) {
                const typed = bestMatch.substring(0, val.length);
                const suggest = bestMatch.substring(val.length);
                document.getElementById('prediction').innerHTML =
                    `<span class="prediction-typed">${typed}</span><span class="prediction-suggest">${suggest}</span>`;
            } else {
                document.getElementById('prediction').innerHTML = '';
            }
        }

        // ==================== DISPLAY FUNCTIONS ====================
        function showHelp() {
            display(`<span class="section-title">‚ïê‚ïê‚ïê COMMANDS ‚ïê‚ïê‚ïê</span>

<span class="highlight">GENERAL</span>
  help              Show this help
  stats             Your stats
  clear             Clear logs

<span class="highlight">TYPING</span>
  type              Start typing challenge
  exit              Leave typing mode

<span class="highlight">SHOP</span>
  shop              View shop
  shop buy [item]   Purchase item
  shop sell [item] [qty]  Sell crops

<span class="highlight">FARM</span>
  farm              View farm
  farm plant [seed] [plot]
  farm water [plot]
  farm fertilize [plot]
  farm harvest [plot]

<span class="highlight">INVENTORY</span>
  inventory / inv   View items

<span class="dim">Plots: A1-A3, B1-B3, C1-C3</span>`);
        }

        function showShop() {
            let html = `<span class="section-title">‚ïê‚ïê‚ïê üè™ SHOP ‚ïê‚ïê‚ïê</span>

<span class="pink">"Welcome! What'll it be?"</span>

<span class="highlight">SEEDS</span>
`;
            for (const [name, item] of Object.entries(state.shopItems)) {
                if (name.includes('seeds')) {
                    html += `  ${name.padEnd(15)} <span class="highlight">${String(item.price).padStart(3)}</span>¬¢  <span class="dim">${item.desc}</span>\n`;
                }
            }
            html += `\n<span class="highlight">TOOLS</span>\n`;
            for (const [name, item] of Object.entries(state.shopItems)) {
                if (!name.includes('seeds')) {
                    html += `  ${name.padEnd(15)} <span class="highlight">${String(item.price).padStart(3)}</span>¬¢  <span class="dim">${item.desc}</span>\n`;
                }
            }
            html += `\n<span class="dim">Your coins:</span> <span class="highlight">${state.coins}</span>`;
            display(html);
        }

        function showFarm() {
            let html = `<span class="section-title">‚ïê‚ïê‚ïê üåæ FARM ‚ïê‚ïê‚ïê</span>\n\n`;

            for (let row = 0; row < 3; row++) {
                const rowLetter = ['A', 'B', 'C'][row];
                let rowDisplay = '  ';
                for (let col = 0; col < 3; col++) {
                    const idx = row * 3 + col;
                    const plot = state.farm[idx];
                    const plotName = `${rowLetter}${col + 1}`;

                    let cell = '[üü´   ]';
                    if (plot) {
                        const elapsed = (Date.now() - plot.plantedAt) / 1000;
                        const progress = Math.min(elapsed / plot.growTime, 1);
                        const crop = state.crops[plot.type];

                        if (progress >= 1) {
                            cell = `[${crop.emoji}<span class="green">RDY</span>]`;
                        } else {
                            const stageIdx = Math.floor(progress * 2);
                            const remaining = Math.ceil(plot.growTime - elapsed);
                            cell = `[${crop.stages[stageIdx]}${String(remaining).padStart(3)}]`;
                        }
                    }
                    rowDisplay += `${plotName}${cell} `;
                }
                html += rowDisplay + '\n';
            }

            html += `\n<span class="dim">üü´=Empty üå±=Growing RDY=Harvest</span>`;
            display(html);
        }

        function showInventory() {
            let html = `<span class="section-title">‚ïê‚ïê‚ïê üéí INVENTORY ‚ïê‚ïê‚ïê</span>\n\n`;
            const items = Object.entries(state.inventory).filter(([k, v]) => v > 0);

            if (items.length === 0) {
                html += `<span class="dim">Empty. Buy seeds from shop!</span>`;
            } else {
                for (const [name, count] of items) {
                    html += `  ${name.padEnd(18)} x${count}\n`;
                }
            }
            display(html);
        }

        function showStats() {
            const acc = state.totalKeystrokes > 0
                ? Math.round((state.correctKeystrokes / state.totalKeystrokes) * 100)
                : 100;
            display(`<span class="section-title">‚ïê‚ïê‚ïê üìä STATS ‚ïê‚ïê‚ïê</span>

  Level:       <span class="highlight">${state.level}</span>
  XP:          <span class="highlight">${state.xp}</span>/${state.level * 100}
  Coins:       <span class="highlight">${state.coins}</span>

  Keystrokes:  ${state.totalKeystrokes}
  Correct:     <span class="green">${state.correctKeystrokes}</span>
  Errors:      <span class="red">${state.incorrectKeystrokes}</span>
  Accuracy:    ${acc}%`);
        }

        function showTyping() {
            state.mode = 'typing';
            state.typingText = state.prompts[Math.floor(Math.random() * state.prompts.length)];
            state.typingIndex = 0;
            state.typingErrors = [];
            renderTyping();
            action('üìù Typing mode started', 'system');
        }

        function renderTyping() {
            let html = `<span class="section-title">‚ïê‚ïê‚ïê ‚å®Ô∏è TYPING ‚ïê‚ïê‚ïê</span>

<span class="dim">Earn ${state.level} coin per correct char!</span>

<div class="typing-area">`;

            for (let i = 0; i < state.typingText.length; i++) {
                const char = state.typingText[i] === ' ' ? '‚ê£' : state.typingText[i];
                const actualChar = state.typingText[i];

                if (i < state.typingIndex) {
                    if (state.typingErrors.includes(i)) {
                        html += `<span class="incorrect">${actualChar}</span>`;
                    } else {
                        html += `<span class="correct">${actualChar}</span>`;
                    }
                } else if (i === state.typingIndex) {
                    html += `<span class="cursor">${actualChar}</span>`;
                } else {
                    html += `<span class="pending">${actualChar}</span>`;
                }
            }

            html += `</div>

<span class="dim">Progress:</span> ${state.typingIndex}/${state.typingText.length}
<span class="dim">Errors:</span> <span class="red">${state.typingErrors.length}</span>
<span class="dim">Type 'exit' to leave</span>`;

            display(html);
        }

        // ==================== COMMANDS ====================
        function handleCommand(input) {
            const raw = input.trim();
            const parts = raw.toLowerCase().split(/\s+/);
            const cmd = parts[0];

            // Typing mode
            if (state.mode === 'typing') {
                if (raw.toLowerCase() === 'exit') {
                    state.mode = 'normal';
                    logCommand('exit', true);
                    action('üëã Left typing mode', 'system');
                    showHelp();
                    return;
                }
                handleTypingInput(raw);
                return;
            }

            // Validate and log command
            const isValid = validateCommand(parts);
            logCommand(raw, isValid);

            if (!isValid) {
                action(`‚ùì Unknown: ${cmd}`, 'error');
                return;
            }

            // Execute command
            switch (cmd) {
                case 'help':
                case '?':
                    showHelp();
                    break;
                case 'type':
                case 'typing':
                    showTyping();
                    break;
                case 'shop':
                    handleShopCommand(parts);
                    break;
                case 'farm':
                    handleFarmCommand(parts);
                    break;
                case 'inventory':
                case 'inv':
                case 'i':
                    showInventory();
                    break;
                case 'stats':
                    showStats();
                    break;
                case 'clear':
                    document.getElementById('actions-log').innerHTML = '';
                    document.getElementById('command-log').innerHTML = '';
                    action('üßπ Cleared', 'system');
                    break;
                case 'save':
                    save();
                    action('üíæ Saved!', 'success');
                    break;
            }
        }

        function validateCommand(parts) {
            const cmd = parts[0];
            const validRoots = ['help', '?', 'type', 'typing', 'shop', 'farm', 'inventory', 'inv', 'i', 'stats', 'clear', 'save', 'exit'];
            return validRoots.includes(cmd);
        }

        function handleShopCommand(parts) {
            if (parts.length === 1) {
                showShop();
                return;
            }

            const action_ = parts[1];

            if (action_ === 'buy') {
                const itemName = parts.slice(2).join(' ');
                const item = state.shopItems[itemName];

                if (!item) {
                    action(`‚ùå Unknown: ${itemName}`, 'error');
                    return;
                }

                if (state.coins < item.price) {
                    action(`‚ùå Need ${item.price}¬¢, have ${state.coins}¬¢`, 'error');
                    return;
                }

                state.coins -= item.price;
                state.inventory[itemName] = (state.inventory[itemName] || 0) + 1;
                action(`‚úÖ Bought ${itemName}`, 'success');
                updateStats();
                save();
                showShop();
            }
            else if (action_ === 'sell') {
                const qty = parseInt(parts[parts.length - 1]) || 1;
                const itemName = parts.slice(2, parseInt(parts[parts.length - 1]) ? -1 : undefined).join(' ');

                if (!state.inventory[itemName] || state.inventory[itemName] < qty) {
                    action(`‚ùå No ${itemName}`, 'error');
                    return;
                }

                const prices = { 'carrot': 25, 'tomato': 50, 'corn': 80, 'pumpkin': 120, 'golden': 400 };
                let sellPrice = 0;
                for (const [name, price] of Object.entries(prices)) {
                    if (itemName.includes(name)) { sellPrice = price; break; }
                }

                if (!sellPrice) {
                    action(`‚ùå Can't sell ${itemName}`, 'error');
                    return;
                }

                state.inventory[itemName] -= qty;
                const total = sellPrice * qty;
                addCoins(total);
                action(`üí∞ Sold ${qty}x ${itemName} for ${total}¬¢`, 'success');
                showInventory();
            }
        }

        function handleFarmCommand(parts) {
            if (parts.length === 1) {
                showFarm();
                return;
            }

            const farmAction = parts[1];

            if (farmAction === 'plant') {
                const plotName = parts[parts.length - 1].toUpperCase();
                const seedName = parts.slice(2, -1).join(' ');
                const plotIdx = getPlotIndex(plotName);

                if (plotIdx === -1) {
                    action(`‚ùå Invalid plot: ${plotName}`, 'error');
                    return;
                }

                if (state.farm[plotIdx]) {
                    action(`‚ùå ${plotName} not empty!`, 'error');
                    return;
                }

                const fullSeedName = seedName.includes('seeds') ? seedName : seedName + ' seeds';

                if (!state.inventory[fullSeedName] || state.inventory[fullSeedName] < 1) {
                    action(`‚ùå No ${fullSeedName}!`, 'error');
                    return;
                }

                if (!state.crops[fullSeedName]) {
                    action(`‚ùå Unknown: ${fullSeedName}`, 'error');
                    return;
                }

                state.inventory[fullSeedName]--;
                state.farm[plotIdx] = {
                    type: fullSeedName,
                    plantedAt: Date.now(),
                    growTime: state.crops[fullSeedName].growTime,
                    watered: false
                };
                action(`üå± Planted in ${plotName}!`, 'success');
                save();
                showFarm();
            }
            else if (farmAction === 'water') {
                const plotName = parts[2]?.toUpperCase();
                const plotIdx = getPlotIndex(plotName);

                if (plotIdx === -1 || !state.farm[plotIdx]) {
                    action(`‚ùå Invalid: ${plotName}`, 'error');
                    return;
                }

                if (!state.farm[plotIdx].watered) {
                    state.farm[plotIdx].watered = true;
                    state.farm[plotIdx].growTime *= 0.8;
                    action(`üíß Watered ${plotName}!`, 'success');
                    save();
                } else {
                    action(`üíß Already watered`, 'warning');
                }
                showFarm();
            }
            else if (farmAction === 'fertilize') {
                const plotName = parts[2]?.toUpperCase();
                const plotIdx = getPlotIndex(plotName);

                if (plotIdx === -1 || !state.farm[plotIdx]) {
                    action(`‚ùå Invalid: ${plotName}`, 'error');
                    return;
                }

                if (!state.inventory['fertilizer'] || state.inventory['fertilizer'] < 1) {
                    action(`‚ùå No fertilizer!`, 'error');
                    return;
                }

                state.inventory['fertilizer']--;
                const elapsed = (Date.now() - state.farm[plotIdx].plantedAt) / 1000;
                const remaining = state.farm[plotIdx].growTime - elapsed;
                state.farm[plotIdx].growTime -= remaining / 2;
                action(`üß™ Fertilized ${plotName}!`, 'success');
                save();
                showFarm();
            }
            else if (farmAction === 'harvest') {
                const plotName = parts[2]?.toUpperCase();
                const plotIdx = getPlotIndex(plotName);

                if (plotIdx === -1 || !state.farm[plotIdx]) {
                    action(`‚ùå Nothing in ${plotName}!`, 'error');
                    return;
                }

                const plot = state.farm[plotIdx];
                const elapsed = (Date.now() - plot.plantedAt) / 1000;

                if (elapsed < plot.growTime) {
                    const remaining = Math.ceil(plot.growTime - elapsed);
                    action(`‚ùå ${remaining}s left!`, 'error');
                    return;
                }

                const crop = state.crops[plot.type];
                const cropName = plot.type.replace(' seeds', '');
                state.inventory[cropName] = (state.inventory[cropName] || 0) + 1;
                state.farm[plotIdx] = null;
                action(`üåæ Harvested ${crop.emoji}!`, 'success');
                save();
                showFarm();
            }
        }

        function handleTypingInput(input) {
            if (!state.startTime) state.startTime = Date.now();

            for (const char of input) {
                if (state.typingIndex >= state.typingText.length) break;

                state.totalKeystrokes++;
                const expected = state.typingText[state.typingIndex];

                if (char === expected) {
                    state.correctKeystrokes++;
                    state.typingIndex++;
                    addCoins(state.level);
                } else {
                    state.incorrectKeystrokes++;
                    state.typingErrors.push(state.typingIndex);
                    state.typingIndex++; // Move forward even on error
                    logTypingError(expected, char);
                }
            }

            if (state.typingIndex >= state.typingText.length) {
                const bonus = Math.max(0, (state.level * 10) - (state.typingErrors.length * 2));
                action(`‚úÖ Complete! +${bonus} bonus`, 'success');
                addCoins(bonus);
                state.typingText = state.prompts[Math.floor(Math.random() * state.prompts.length)];
                state.typingIndex = 0;
                state.typingErrors = [];
            }

            updateStats();
            renderTyping();
        }

        // ==================== INIT ====================
        function init() {
            load();
            updateStats();

            const inputEl = document.getElementById('input');

            inputEl.addEventListener('input', (e) => {
                updatePrediction(e.target.value);
            });

            inputEl.addEventListener('keypress', (e) => {
                if (e.key === 'Enter' && e.target.value.trim()) {
                    handleCommand(e.target.value);
                    e.target.value = '';
                    updatePrediction('');
                }
            });

            // Auto-refresh farm
            setInterval(() => {
                const disp = document.getElementById('display');
                if (disp.innerHTML.includes('FARM')) showFarm();
            }, 1000);

            action('üå± Welcome to TypeFarm!', 'success');
            action("Type 'help' to start", 'system');
            showHelp();
        }

        init();
    </script>
</body>
</html>
