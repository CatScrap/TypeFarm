<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TypeFarm</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        :root {
            --bg-dark: #0a0a0f;
            --bg-panel: #12121a;
            --bg-input: #1a1a25;
            --text-primary: #e8e8e8;
            --text-dim: #555;
            --text-predict: #444;
            --accent-cyan: #00d9ff;
            --accent-green: #00ff88;
            --accent-yellow: #ffd700;
            --accent-red: #ff4757;
            --accent-pink: #ff9ff3;
            --border: #2a2a3a;
        }

        body {
            font-family: 'Courier New', monospace;
            background: var(--bg-dark);
            color: var(--text-primary);
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .header {
            background: var(--bg-panel);
            border-bottom: 1px solid var(--border);
            padding: 0.6rem 1.5rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .header h1 {
            font-size: 1.3rem;
            background: linear-gradient(90deg, var(--accent-cyan), var(--accent-green));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .stats {
            display: flex;
            gap: 1.2rem;
            font-size: 0.85rem;
        }

        .stat span { color: var(--accent-yellow); }

        /* Three Lane Layout */
        .lanes {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        .lane {
            display: flex;
            flex-direction: column;
            border-right: 1px solid var(--border);
            overflow: hidden;
        }

        .lane:last-child { border-right: none; }

        .lane-actions { width: 25%; }
        .lane-commands { width: 25%; }
        .lane-game { width: 50%; }

        .lane-header {
            padding: 0.4rem 0.8rem;
            background: var(--bg-input);
            border-bottom: 1px solid var(--border);
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .lane-actions .lane-header { color: var(--accent-cyan); }
        .lane-commands .lane-header { color: var(--accent-pink); }
        .lane-game .lane-header { color: var(--accent-green); }

        .lane-content {
            flex: 1;
            overflow-y: auto;
            padding: 0.6rem;
            font-size: 0.8rem;
            line-height: 1.5;
        }

        .lane-game .lane-content {
            white-space: pre-wrap;
            font-size: 0.85rem;
        }

        /* Log Entries */
        .log-entry {
            margin-bottom: 0.3rem;
            padding: 0.2rem 0;
        }

        .log-system { color: var(--accent-cyan); }
        .log-success { color: var(--accent-green); }
        .log-warning { color: var(--accent-yellow); }
        .log-error { color: var(--accent-red); }

        /* Command Log */
        .cmd-entry {
            margin-bottom: 0.3rem;
            padding: 0.2rem 0.4rem;
            border-radius: 3px;
        }

        .cmd-valid {
            color: var(--accent-green);
            background: rgba(0, 255, 136, 0.05);
        }

        .cmd-invalid {
            color: var(--accent-red);
            background: rgba(255, 71, 87, 0.1);
        }

        .cmd-prefix {
            color: var(--text-dim);
            margin-right: 0.3rem;
        }

        /* Terminal Input */
        .terminal-bar {
            background: var(--bg-panel);
            border-top: 1px solid var(--border);
            padding: 0.6rem 1rem;
        }

        .input-wrapper {
            position: relative;
            display: flex;
            align-items: center;
            background: var(--bg-input);
            border: 1px solid var(--border);
            border-radius: 4px;
            padding: 0.5rem 0.8rem;
        }

        .input-wrapper:focus-within {
            border-color: var(--accent-cyan);
        }

        .terminal-prompt {
            color: var(--accent-green);
            margin-right: 0.5rem;
        }

        .input-container {
            position: relative;
            flex: 1;
            font-family: 'Courier New', monospace;
        }

        .terminal-input {
            width: 100%;
            background: transparent;
            border: none;
            font-family: inherit;
            font-size: 1rem;
            color: var(--text-primary);
            outline: none;
            caret-color: var(--accent-cyan);
        }

        .prediction-text {
            position: absolute;
            top: 0;
            left: 0;
            font-size: 1rem;
            color: var(--text-predict);
            pointer-events: none;
            user-select: none;
        }

        /* Scrollbar */
        ::-webkit-scrollbar { width: 5px; }
        ::-webkit-scrollbar-track { background: var(--bg-dark); }
        ::-webkit-scrollbar-thumb { background: var(--border); border-radius: 3px; }

        /* Game Display */
        .section-title { color: var(--accent-cyan); margin-bottom: 0.5rem; }
        .highlight { color: var(--accent-yellow); }
        .dim { color: var(--text-dim); }
        .green { color: var(--accent-green); }
        .red { color: var(--accent-red); }
        .pink { color: var(--accent-pink); }
        .cyan { color: var(--accent-cyan); }
    </style>
</head>
<body>
    <header class="header">
        <h1>üå± TypeFarm</h1>
        <div class="stats">
            <div>üí∞ <span id="coins">50</span></div>
            <div>üåæ Season: <span id="season">Spring</span></div>
            <div>üìÖ Day <span id="day">1</span></div>
        </div>
    </header>

    <main class="lanes">
        <aside class="lane lane-actions">
            <div class="lane-header">üì° Actions</div>
            <div class="lane-content" id="actions-log"></div>
        </aside>

        <aside class="lane lane-commands">
            <div class="lane-header">üìù Command Log</div>
            <div class="lane-content" id="command-log"></div>
        </aside>

        <section class="lane lane-game">
            <div class="lane-header">üéÆ Game</div>
            <div class="lane-content" id="display"></div>
        </section>
    </main>

    <footer class="terminal-bar">
        <div class="input-wrapper">
            <span class="terminal-prompt">$</span>
            <div class="input-container">
                <span class="prediction-text" id="prediction"></span>
                <input type="text" class="terminal-input" id="input" autocomplete="off" autofocus>
            </div>
        </div>
    </footer>

    <script>
        // ==================== GAME STATE ====================
        const state = {
            coins: 50,
            day: 1,
            season: 'Spring',
            location: 'home',
            vehicle: 'bike',
            inventory: {},
            farm: Array(9).fill(null),
            // Travel state
            traveling: false,
            travelDest: null,
            travelProgress: 0,
            travelTarget: 100,
            travelText: '',
            travelIndex: 0,
            travelErrors: 0,
            shopItems: {
                'carrot seeds': { price: 10, desc: 'Grows 30s, sells 25' },
                'tomato seeds': { price: 20, desc: 'Grows 45s, sells 50' },
                'corn seeds': { price: 35, desc: 'Grows 60s, sells 80' },
                'pumpkin seeds': { price: 50, desc: 'Grows 90s, sells 120' },
                'golden seeds': { price: 150, desc: 'Grows 120s, sells 400' },
                'fertilizer': { price: 25, desc: 'Halves grow time' },
                'watering can': { price: 100, desc: 'Auto-water crops' },
                'scooter': { price: 200, desc: 'Faster than bike, less typing' },
                'car': { price: 500, desc: 'Much faster, minimal typing' },
                'truck': { price: 1000, desc: 'Instant travel!' }
            },
            vehicles: {
                'bike': { emoji: 'üö≤', speed: 5, owned: true },
                'scooter': { emoji: 'üõµ', speed: 15, owned: false },
                'car': { emoji: 'üöó', speed: 30, owned: false },
                'truck': { emoji: 'üöö', speed: 100, owned: false }
            },
            locations: {
                'home': { emoji: 'üè†', name: 'Home' },
                'shop': { emoji: 'üè™', name: 'Shop' },
                'farm': { emoji: 'üåæ', name: 'Farm' }
            },
            crops: {
                'carrot seeds': { growTime: 30, emoji: 'ü•ï', sellPrice: 25, stages: ['üå±', 'üåø', 'ü•ï'] },
                'tomato seeds': { growTime: 45, emoji: 'üçÖ', sellPrice: 50, stages: ['üå±', 'üåø', 'üçÖ'] },
                'corn seeds': { growTime: 60, emoji: 'üåΩ', sellPrice: 80, stages: ['üå±', 'üåæ', 'üåΩ'] },
                'pumpkin seeds': { growTime: 90, emoji: 'üéÉ', sellPrice: 120, stages: ['üå±', 'üåø', 'üéÉ'] },
                'golden seeds': { growTime: 120, emoji: '‚ú®', sellPrice: 400, stages: ['üå±', 'üí´', '‚ú®'] }
            },
            travelPhrases: [
                "pedal faster down the road",
                "watch out for that pothole",
                "the wind feels nice today",
                "almost there keep going",
                "beautiful day for a ride",
                "the farm is just ahead",
                "steady pace wins the race",
                "enjoy the countryside view"
            ]
        };

        const plotNames = ['A1', 'A2', 'A3', 'B1', 'B2', 'B3', 'C1', 'C2', 'C3'];

        // Travel minigame state
        const travelState = {
            active: false,
            destination: null,
            vehicleType: 'bike',
            position: 2, // 0-4 lanes (left to right)
            distance: 0,
            totalDistance: 100,
            score: 0,
            health: 100, // for bike
            fuel: 100, // for car/truck
            obstacles: [],
            currentDirection: null,
            typedText: '',
            correctChars: 0,
            totalChars: 0,
            errors: 0,
            startTime: null,
            lastKeyTime: null,
            idleTime: 0,
            wordsTyped: 0,
            perfectWords: 0,
            gameLoop: null,
            obstacleSpeed: 1,
            spawnRate: 60, // frames between spawns
            frameCount: 0
        };

        const directions = ['left', 'right', 'up', 'dodge', 'jump', 'duck', 'swerve', 'brake'];

        // All possible commands for prediction
        const allCommands = [
            'help',
            'shop', 'shop buy carrot seeds', 'shop buy tomato seeds',
            'shop buy corn seeds', 'shop buy pumpkin seeds', 'shop buy golden seeds',
            'shop buy fertilizer', 'shop buy watering can',
            'shop sell carrot', 'shop sell tomato', 'shop sell corn', 'shop sell pumpkin', 'shop sell golden',
            'farm',
            'farm plant carrot A1', 'farm plant carrot A2', 'farm plant carrot A3',
            'farm plant carrot B1', 'farm plant carrot B2', 'farm plant carrot B3',
            'farm plant carrot C1', 'farm plant carrot C2', 'farm plant carrot C3',
            'farm plant tomato A1', 'farm plant tomato A2', 'farm plant tomato A3',
            'farm plant corn A1', 'farm plant pumpkin A1', 'farm plant golden A1',
            'farm water A1', 'farm water A2', 'farm water A3',
            'farm water B1', 'farm water B2', 'farm water B3',
            'farm water C1', 'farm water C2', 'farm water C3',
            'farm harvest A1', 'farm harvest A2', 'farm harvest A3',
            'farm harvest B1', 'farm harvest B2', 'farm harvest B3',
            'farm harvest C1', 'farm harvest C2', 'farm harvest C3',
            'farm fertilize A1', 'farm fertilize B1', 'farm fertilize C1',
            'inventory', 'inv',
            'stats',
            'clear',
            'save',
            'bike go home', 'bike go shop', 'bike go farm', 'bike status',
            'scooter go home', 'scooter go shop', 'scooter go farm', 'scooter status',
            'car go home', 'car go shop', 'car go farm', 'car status',
            'truck go home', 'truck go shop', 'truck go farm', 'truck status',
            'go home', 'go shop', 'go farm',
            'location', 'where'
        ];

        // ==================== UTILITIES ====================
        function save() { localStorage.setItem('typefarm', JSON.stringify(state)); }

        function load() {
            const saved = localStorage.getItem('typefarm');
            if (saved) Object.assign(state, JSON.parse(saved));
        }

        function action(msg, type = 'system') {
            const el = document.getElementById('actions-log');
            const entry = document.createElement('div');
            entry.className = `log-entry log-${type}`;
            entry.textContent = msg;
            el.appendChild(entry);
            el.scrollTop = el.scrollHeight;
        }

        function logCommand(cmd, valid) {
            const el = document.getElementById('command-log');
            const entry = document.createElement('div');
            entry.className = `cmd-entry ${valid ? 'cmd-valid' : 'cmd-invalid'}`;
            entry.innerHTML = `<span class="cmd-prefix">$</span>${cmd}`;
            el.appendChild(entry);
            el.scrollTop = el.scrollHeight;
        }

        function display(content) {
            document.getElementById('display').innerHTML = content;
        }

        function updateStats() {
            document.getElementById('coins').textContent = state.coins;
            document.getElementById('day').textContent = state.day;
            document.getElementById('season').textContent = state.season;
        }

        function addCoins(n) {
            state.coins += n;
            updateStats();
            save();
        }

        function getPlotIndex(name) {
            return plotNames.indexOf(name.toUpperCase());
        }

        // ==================== PREDICTION ====================
        function updatePrediction(inputValue) {
            const predictionEl = document.getElementById('prediction');
            const val = inputValue.toLowerCase();

            if (!val) {
                predictionEl.textContent = '';
                return;
            }

            // Find best matching command
            let bestMatch = '';
            for (const cmd of allCommands) {
                if (cmd.toLowerCase().startsWith(val) && cmd.length > val.length) {
                    bestMatch = cmd;
                    break;
                }
            }

            if (bestMatch) {
                // Show the full predicted command (typed part + suggestion)
                predictionEl.textContent = bestMatch;
            } else {
                predictionEl.textContent = '';
            }
        }

        // ==================== DISPLAY FUNCTIONS ====================
        function showHelp() {
            display(`<span class="section-title">‚ïê‚ïê‚ïê COMMANDS ‚ïê‚ïê‚ïê</span>

<span class="highlight">GENERAL</span>
  help              Show this help
  stats             Your farm stats
  clear             Clear logs
  save              Save game

<span class="highlight">TRAVEL</span>
  location / where  Show current location
  [vehicle] go [dest]  Travel somewhere
  [vehicle] status  Check vehicle health/fuel
  <span class="dim">Vehicles: bike, scooter, car, truck</span>
  <span class="dim">Destinations: home, shop, farm</span>

<span class="highlight">SHOP</span>
  shop              View shop
  shop buy [item]   Purchase item
  shop sell [item] [qty]  Sell crops

<span class="highlight">FARM</span>
  farm              View farm
  farm plant [seed] [plot]
  farm water [plot]
  farm fertilize [plot]
  farm harvest [plot]

<span class="highlight">INVENTORY</span>
  inventory / inv   View items

<span class="dim">Plots: A1-A3, B1-B3, C1-C3</span>
<span class="dim">Example: bike go shop</span>`);
        }

        function showShop() {
            let html = `<span class="section-title">‚ïê‚ïê‚ïê üè™ SHOP ‚ïê‚ïê‚ïê</span>

<span class="pink">"Welcome to the farm shop!"</span>

<span class="highlight">SEEDS</span>
`;
            for (const [name, item] of Object.entries(state.shopItems)) {
                if (name.includes('seeds')) {
                    html += `  ${name.padEnd(15)} <span class="highlight">${String(item.price).padStart(3)}</span>¬¢  <span class="dim">${item.desc}</span>\n`;
                }
            }
            html += `\n<span class="highlight">TOOLS</span>\n`;
            for (const [name, item] of Object.entries(state.shopItems)) {
                if (!name.includes('seeds') && !['scooter', 'car', 'truck'].includes(name)) {
                    html += `  ${name.padEnd(15)} <span class="highlight">${String(item.price).padStart(3)}</span>¬¢  <span class="dim">${item.desc}</span>\n`;
                }
            }
            html += `\n<span class="highlight">VEHICLES</span>\n`;
            for (const [name, item] of Object.entries(state.shopItems)) {
                if (['scooter', 'car', 'truck'].includes(name)) {
                    const owned = state.vehicles[name]?.owned;
                    if (owned) {
                        html += `  ${name.padEnd(15)} <span class="green">OWNED</span>\n`;
                    } else {
                        html += `  ${name.padEnd(15)} <span class="highlight">${String(item.price).padStart(3)}</span>¬¢  <span class="dim">${item.desc}</span>\n`;
                    }
                }
            }
            html += `\n<span class="dim">Your coins:</span> <span class="highlight">${state.coins}</span>`;
            display(html);
        }

        function showFarm() {
            let html = `<span class="section-title">‚ïê‚ïê‚ïê üåæ FARM ‚ïê‚ïê‚ïê</span>\n\n`;

            for (let row = 0; row < 3; row++) {
                const rowLetter = ['A', 'B', 'C'][row];
                let rowDisplay = '  ';
                for (let col = 0; col < 3; col++) {
                    const idx = row * 3 + col;
                    const plot = state.farm[idx];
                    const plotName = `${rowLetter}${col + 1}`;

                    let cell = '[üü´   ]';
                    if (plot) {
                        const elapsed = (Date.now() - plot.plantedAt) / 1000;
                        const progress = Math.min(elapsed / plot.growTime, 1);
                        const crop = state.crops[plot.type];

                        if (progress >= 1) {
                            cell = `[${crop.emoji}<span class="green">RDY</span>]`;
                        } else {
                            const stageIdx = Math.floor(progress * 2);
                            const remaining = Math.ceil(plot.growTime - elapsed);
                            cell = `[${crop.stages[stageIdx]}${String(remaining).padStart(3)}]`;
                        }
                    }
                    rowDisplay += `${plotName}${cell} `;
                }
                html += rowDisplay + '\n';
            }

            html += `\n<span class="dim">üü´=Empty üå±=Growing RDY=Ready to harvest</span>`;
            display(html);
        }

        function showInventory() {
            let html = `<span class="section-title">‚ïê‚ïê‚ïê üéí INVENTORY ‚ïê‚ïê‚ïê</span>\n\n`;
            const items = Object.entries(state.inventory).filter(([k, v]) => v > 0);

            if (items.length === 0) {
                html += `<span class="dim">Empty. Buy seeds from shop!</span>`;
            } else {
                for (const [name, count] of items) {
                    html += `  ${name.padEnd(18)} x${count}\n`;
                }
            }
            display(html);
        }

        function showStats() {
            display(`<span class="section-title">‚ïê‚ïê‚ïê üìä FARM STATS ‚ïê‚ïê‚ïê</span>

  Coins:       <span class="highlight">${state.coins}</span>¬¢
  Day:         <span class="highlight">${state.day}</span>
  Season:      <span class="highlight">${state.season}</span>

  Plots Used:  ${state.farm.filter(p => p !== null).length}/9

<span class="dim">Keep farming to earn more coins!</span>`);
        }

        // ==================== COMMANDS ====================
        let lastCommandSuccess = true;

        function handleCommand(input) {
            const raw = input.trim();
            const parts = raw.toLowerCase().split(/\s+/);
            const cmd = parts[0];

            // Validate root command
            const validRoots = ['help', '?', 'shop', 'farm', 'inventory', 'inv', 'i', 'stats', 'clear', 'save',
                               'bike', 'scooter', 'car', 'truck', 'go', 'location', 'where'];
            const isValidRoot = validRoots.includes(cmd);

            if (!isValidRoot) {
                logCommand(raw, false);
                action(`‚ùì Unknown: "${cmd}"`, 'error');
                return;
            }

            // Check if traveling - only allow travel input
            if (travelState.active) {
                handleTravelInput(raw);
                logCommand(raw, lastCommandSuccess);
                return;
            }

            // Execute command and track success
            lastCommandSuccess = true;

            switch (cmd) {
                case 'help':
                case '?':
                    showHelp();
                    break;
                case 'shop':
                    handleShopCommand(parts);
                    break;
                case 'farm':
                    handleFarmCommand(parts);
                    break;
                case 'inventory':
                case 'inv':
                case 'i':
                    showInventory();
                    break;
                case 'stats':
                    showStats();
                    break;
                case 'clear':
                    document.getElementById('actions-log').innerHTML = '';
                    document.getElementById('command-log').innerHTML = '';
                    action('üßπ Cleared', 'system');
                    break;
                case 'save':
                    save();
                    action('üíæ Saved!', 'success');
                    break;
                case 'bike':
                case 'scooter':
                case 'car':
                case 'truck':
                    handleVehicleCommand(parts, cmd);
                    break;
                case 'go':
                    // Use current vehicle
                    handleVehicleCommand(['go', ...parts.slice(1)], state.vehicle);
                    break;
                case 'location':
                case 'where':
                    showLocation();
                    break;
            }

            // Log command with actual success status
            logCommand(raw, lastCommandSuccess);
        }

        function commandFailed() {
            lastCommandSuccess = false;
        }

        function handleShopCommand(parts) {
            if (parts.length === 1) {
                showShop();
                return;
            }

            const shopAction = parts[1];

            if (shopAction === 'buy') {
                const itemName = parts.slice(2).join(' ');
                const item = state.shopItems[itemName];

                if (!item) {
                    action(`‚ùå Unknown item: "${itemName}"`, 'error');
                    commandFailed();
                    return;
                }

                // Check if it's a vehicle
                if (['scooter', 'car', 'truck'].includes(itemName)) {
                    if (state.vehicles[itemName]?.owned) {
                        action(`‚ùå You already own a ${itemName}!`, 'error');
                        commandFailed();
                        return;
                    }

                    if (state.coins < item.price) {
                        action(`‚ùå Need ${item.price}¬¢, have ${state.coins}¬¢`, 'error');
                        commandFailed();
                        return;
                    }

                    state.coins -= item.price;
                    state.vehicles[itemName].owned = true;
                    state.vehicles[itemName].health = 100;
                    state.vehicles[itemName].fuel = 100;
                    action(`‚úÖ Bought ${itemName} for ${item.price}¬¢!`, 'success');
                    action(`üöó Use: ${itemName} go [destination]`, 'system');
                    updateStats();
                    save();
                    showShop();
                    return;
                }

                if (state.coins < item.price) {
                    action(`‚ùå Need ${item.price}¬¢, have ${state.coins}¬¢`, 'error');
                    commandFailed();
                    return;
                }

                state.coins -= item.price;
                state.inventory[itemName] = (state.inventory[itemName] || 0) + 1;
                action(`‚úÖ Bought ${itemName} for ${item.price}¬¢`, 'success');
                updateStats();
                save();
                showShop();
            }
            else if (shopAction === 'sell') {
                const qty = parseInt(parts[parts.length - 1]) || 1;
                const hasQty = !isNaN(parseInt(parts[parts.length - 1]));
                const itemName = parts.slice(2, hasQty ? -1 : undefined).join(' ');

                if (!state.inventory[itemName] || state.inventory[itemName] < qty) {
                    action(`‚ùå Don't have ${qty}x ${itemName}`, 'error');
                    commandFailed();
                    return;
                }

                const prices = { 'carrot': 25, 'tomato': 50, 'corn': 80, 'pumpkin': 120, 'golden': 400 };
                let sellPrice = 0;
                for (const [name, price] of Object.entries(prices)) {
                    if (itemName.includes(name)) { sellPrice = price; break; }
                }

                if (!sellPrice) {
                    action(`‚ùå Can't sell "${itemName}"`, 'error');
                    commandFailed();
                    return;
                }

                state.inventory[itemName] -= qty;
                if (state.inventory[itemName] <= 0) delete state.inventory[itemName];
                const total = sellPrice * qty;
                addCoins(total);
                action(`üí∞ Sold ${qty}x ${itemName} for ${total}¬¢`, 'success');
                showInventory();
            }
            else {
                action(`‚ùå Unknown shop command: "${shopAction}"`, 'error');
                commandFailed();
            }
        }

        function handleFarmCommand(parts) {
            if (parts.length === 1) {
                showFarm();
                return;
            }

            const farmAction = parts[1];

            if (farmAction === 'plant') {
                const plotName = parts[parts.length - 1].toUpperCase();
                const seedName = parts.slice(2, -1).join(' ');
                const plotIdx = getPlotIndex(plotName);

                if (plotIdx === -1) {
                    action(`‚ùå Invalid plot: "${plotName}"`, 'error');
                    commandFailed();
                    return;
                }

                if (state.farm[plotIdx]) {
                    action(`‚ùå Plot ${plotName} is occupied!`, 'error');
                    commandFailed();
                    return;
                }

                const fullSeedName = seedName.includes('seeds') ? seedName : seedName + ' seeds';

                if (!state.inventory[fullSeedName] || state.inventory[fullSeedName] < 1) {
                    action(`‚ùå No ${fullSeedName} in inventory`, 'error');
                    commandFailed();
                    return;
                }

                if (!state.crops[fullSeedName]) {
                    action(`‚ùå Unknown seed: "${fullSeedName}"`, 'error');
                    commandFailed();
                    return;
                }

                state.inventory[fullSeedName]--;
                if (state.inventory[fullSeedName] <= 0) delete state.inventory[fullSeedName];

                state.farm[plotIdx] = {
                    type: fullSeedName,
                    plantedAt: Date.now(),
                    growTime: state.crops[fullSeedName].growTime,
                    watered: false
                };
                action(`üå± Planted ${seedName} in ${plotName}`, 'success');
                save();
                showFarm();
            }
            else if (farmAction === 'water') {
                const plotName = parts[2]?.toUpperCase();
                const plotIdx = getPlotIndex(plotName);

                if (plotIdx === -1) {
                    action(`‚ùå Invalid plot: "${plotName}"`, 'error');
                    commandFailed();
                    return;
                }

                if (!state.farm[plotIdx]) {
                    action(`‚ùå Nothing in ${plotName}`, 'error');
                    commandFailed();
                    return;
                }

                if (!state.farm[plotIdx].watered) {
                    state.farm[plotIdx].watered = true;
                    state.farm[plotIdx].growTime *= 0.8;
                    action(`üíß Watered ${plotName}! +20% growth`, 'success');
                    save();
                } else {
                    action(`üíß ${plotName} already watered`, 'warning');
                }
                showFarm();
            }
            else if (farmAction === 'fertilize') {
                const plotName = parts[2]?.toUpperCase();
                const plotIdx = getPlotIndex(plotName);

                if (plotIdx === -1) {
                    action(`‚ùå Invalid plot: "${plotName}"`, 'error');
                    commandFailed();
                    return;
                }

                if (!state.farm[plotIdx]) {
                    action(`‚ùå Nothing in ${plotName}`, 'error');
                    commandFailed();
                    return;
                }

                if (!state.inventory['fertilizer'] || state.inventory['fertilizer'] < 1) {
                    action(`‚ùå No fertilizer!`, 'error');
                    commandFailed();
                    return;
                }

                state.inventory['fertilizer']--;
                if (state.inventory['fertilizer'] <= 0) delete state.inventory['fertilizer'];

                const elapsed = (Date.now() - state.farm[plotIdx].plantedAt) / 1000;
                const remaining = state.farm[plotIdx].growTime - elapsed;
                state.farm[plotIdx].growTime -= remaining / 2;
                action(`üß™ Fertilized ${plotName}! Time halved`, 'success');
                save();
                showFarm();
            }
            else if (farmAction === 'harvest') {
                const plotName = parts[2]?.toUpperCase();
                const plotIdx = getPlotIndex(plotName);

                if (plotIdx === -1) {
                    action(`‚ùå Invalid plot: "${plotName}"`, 'error');
                    commandFailed();
                    return;
                }

                if (!state.farm[plotIdx]) {
                    action(`‚ùå Nothing in ${plotName}`, 'error');
                    commandFailed();
                    return;
                }

                const plot = state.farm[plotIdx];
                const elapsed = (Date.now() - plot.plantedAt) / 1000;

                if (elapsed < plot.growTime) {
                    const remaining = Math.ceil(plot.growTime - elapsed);
                    action(`‚ùå Not ready! ${remaining}s left`, 'error');
                    commandFailed();
                    return;
                }

                const crop = state.crops[plot.type];
                const cropName = plot.type.replace(' seeds', '');
                state.inventory[cropName] = (state.inventory[cropName] || 0) + 1;
                state.farm[plotIdx] = null;
                action(`üåæ Harvested ${crop.emoji} ${cropName}!`, 'success');
                action(`üí° Sell with: shop sell ${cropName} 1`, 'system');
                save();
                showFarm();
            }
            else {
                action(`‚ùå Unknown farm command: "${farmAction}"`, 'error');
                commandFailed();
            }
        }

        // ==================== VEHICLE & TRAVEL ====================
        function showLocation() {
            const loc = state.locations[state.location];
            const veh = state.vehicles[state.vehicle];
            display(`<span class="section-title">‚ïê‚ïê‚ïê üìç LOCATION ‚ïê‚ïê‚ïê</span>

  Current: ${loc.emoji} ${loc.name}
  Vehicle: ${veh.emoji} ${state.vehicle}

<span class="highlight">AVAILABLE DESTINATIONS</span>
${Object.entries(state.locations)
    .filter(([k]) => k !== state.location)
    .map(([k, v]) => `  ${v.emoji} ${v.name.padEnd(8)} - ${state.vehicle} go ${k}`)
    .join('\n')}

<span class="highlight">VEHICLES</span>
${Object.entries(state.vehicles)
    .map(([k, v]) => `  ${v.emoji} ${k.padEnd(8)} ${v.owned ? '<span class="green">Owned</span>' : '<span class="dim">Buy at shop</span>'}`)
    .join('\n')}

<span class="dim">Travel by typing: [vehicle] go [destination]</span>`);
        }

        function handleVehicleCommand(parts, vehicleType) {
            const vehicle = state.vehicles[vehicleType];

            if (!vehicle) {
                action(`‚ùå Unknown vehicle: "${vehicleType}"`, 'error');
                commandFailed();
                return;
            }

            if (!vehicle.owned) {
                action(`‚ùå You don't own a ${vehicleType}! Buy it from shop.`, 'error');
                commandFailed();
                return;
            }

            const subCmd = parts[1];

            if (!subCmd || subCmd === 'status') {
                showVehicleStatus(vehicleType);
                return;
            }

            if (subCmd === 'go') {
                const dest = parts[2];
                if (!dest || !state.locations[dest]) {
                    action(`‚ùå Unknown destination: "${dest || ''}"`, 'error');
                    action(`üìç Try: home, shop, or farm`, 'system');
                    commandFailed();
                    return;
                }

                if (dest === state.location) {
                    action(`üìç You're already at ${state.locations[dest].name}!`, 'warning');
                    commandFailed();
                    return;
                }

                startTravel(vehicleType, dest);
            } else {
                action(`‚ùå Unknown ${vehicleType} command: "${subCmd}"`, 'error');
                commandFailed();
            }
        }

        function showVehicleStatus(vehicleType) {
            const v = state.vehicles[vehicleType];
            const isCurrent = state.vehicle === vehicleType;

            let statusBar = '';
            if (vehicleType === 'bike' || vehicleType === 'scooter') {
                const health = v.health || 100;
                const bars = Math.floor(health / 10);
                statusBar = `Health: [${'‚ñà'.repeat(bars)}${'‚ñë'.repeat(10-bars)}] ${health}%`;
            } else {
                const fuel = v.fuel || 100;
                const bars = Math.floor(fuel / 10);
                statusBar = `Fuel:   [${'‚ñà'.repeat(bars)}${'‚ñë'.repeat(10-bars)}] ${fuel}%`;
            }

            display(`<span class="section-title">‚ïê‚ïê‚ïê ${v.emoji} ${vehicleType.toUpperCase()} STATUS ‚ïê‚ïê‚ïê</span>

  ${statusBar}
  Speed:  ${v.speed} (less typing needed)
  ${isCurrent ? '<span class="green">‚úì Currently selected</span>' : '<span class="dim">Type: ' + vehicleType + ' go [dest] to use</span>'}

<span class="dim">Travel to repair/refuel at home</span>`);
        }

        function startTravel(vehicleType, destination) {
            const vehicle = state.vehicles[vehicleType];

            // Check health/fuel
            if ((vehicleType === 'bike' || vehicleType === 'scooter') && (vehicle.health || 100) <= 0) {
                action(`‚ùå Your ${vehicleType} is broken! Go home to repair.`, 'error');
                commandFailed();
                return;
            }
            if ((vehicleType === 'car' || vehicleType === 'truck') && (vehicle.fuel || 100) <= 0) {
                action(`‚ùå Your ${vehicleType} is out of fuel! Go home to refuel.`, 'error');
                commandFailed();
                return;
            }

            // Initialize travel state
            travelState.active = true;
            travelState.destination = destination;
            travelState.vehicleType = vehicleType;
            travelState.position = 2;
            travelState.distance = 0;
            travelState.totalDistance = Math.max(20, 100 - vehicle.speed);
            travelState.score = 0;
            travelState.health = vehicle.health || 100;
            travelState.fuel = vehicle.fuel || 100;
            travelState.obstacles = [];
            travelState.currentDirection = getRandomDirection();
            travelState.typedText = '';
            travelState.correctChars = 0;
            travelState.totalChars = 0;
            travelState.errors = 0;
            travelState.startTime = Date.now();
            travelState.lastKeyTime = Date.now();
            travelState.idleTime = 0;
            travelState.wordsTyped = 0;
            travelState.perfectWords = 0;
            travelState.frameCount = 0;
            travelState.obstacleSpeed = 1 + (vehicle.speed / 50);
            travelState.spawnRate = Math.max(30, 80 - vehicle.speed);

            state.vehicle = vehicleType;

            action(`${vehicle.emoji} Starting trip to ${state.locations[destination].name}!`, 'success');
            action(`‚å®Ô∏è Type directions to dodge obstacles!`, 'system');

            // Start game loop
            travelState.gameLoop = setInterval(updateTravel, 50);
            renderTravel();
        }

        function getRandomDirection() {
            return directions[Math.floor(Math.random() * directions.length)];
        }

        function handleTravelInput(input) {
            const typed = input.toLowerCase().trim();
            const target = travelState.currentDirection;

            travelState.lastKeyTime = Date.now();

            if (typed === target) {
                // Correct word!
                travelState.wordsTyped++;
                travelState.perfectWords++;
                travelState.correctChars += target.length;
                travelState.totalChars += target.length;
                travelState.score += 10;
                travelState.distance += 5;

                // Move position based on direction
                if (typed === 'left' || typed === 'swerve') {
                    travelState.position = Math.max(0, travelState.position - 1);
                } else if (typed === 'right') {
                    travelState.position = Math.min(4, travelState.position + 1);
                }

                // Clear obstacles in current lane
                travelState.obstacles = travelState.obstacles.filter(o => o.lane !== travelState.position || o.y < 8);

                travelState.currentDirection = getRandomDirection();
                travelState.typedText = '';
                action(`‚úÖ ${typed}! +10pts`, 'success');
                lastCommandSuccess = true;
            } else {
                // Wrong word
                travelState.errors++;
                travelState.totalChars += typed.length;
                travelState.wordsTyped++;

                const vehicle = state.vehicles[travelState.vehicleType];
                if (travelState.vehicleType === 'bike' || travelState.vehicleType === 'scooter') {
                    travelState.health -= 10;
                    vehicle.health = travelState.health;
                    action(`‚ùå Wrong! -10 health (${travelState.health}%)`, 'error');
                } else {
                    travelState.fuel -= 5;
                    vehicle.fuel = travelState.fuel;
                    action(`‚ùå Wrong! -5 fuel (${travelState.fuel}%)`, 'error');
                }

                lastCommandSuccess = false;
                travelState.currentDirection = getRandomDirection();
                travelState.typedText = '';
            }

            renderTravel();
        }

        function updateTravel() {
            travelState.frameCount++;

            // Update idle time
            const idleMs = Date.now() - travelState.lastKeyTime;
            travelState.idleTime += 50;

            // Auto-progress distance slowly
            travelState.distance += 0.1;

            // Spawn obstacles
            if (travelState.frameCount % travelState.spawnRate === 0) {
                const lane = Math.floor(Math.random() * 5);
                const obstacles = ['üöß', 'ü™®', 'üå≤', 'üöó', 'üêÑ', 'ü¶Ü'];
                travelState.obstacles.push({
                    lane: lane,
                    y: 0,
                    emoji: obstacles[Math.floor(Math.random() * obstacles.length)]
                });
            }

            // Move obstacles down
            travelState.obstacles.forEach(o => {
                o.y += travelState.obstacleSpeed * 0.1;
            });

            // Check collisions
            travelState.obstacles = travelState.obstacles.filter(o => {
                if (o.y >= 8 && o.y <= 10 && o.lane === travelState.position) {
                    // Collision!
                    const vehicle = state.vehicles[travelState.vehicleType];
                    if (travelState.vehicleType === 'bike' || travelState.vehicleType === 'scooter') {
                        travelState.health -= 15;
                        vehicle.health = travelState.health;
                    } else {
                        travelState.fuel -= 10;
                        vehicle.fuel = travelState.fuel;
                    }
                    travelState.score -= 5;
                    action(`üí• Hit ${o.emoji}!`, 'warning');
                    return false;
                }
                return o.y < 12;
            });

            // Check win/lose conditions
            if (travelState.distance >= travelState.totalDistance) {
                endTravel(true);
                return;
            }

            if ((travelState.vehicleType === 'bike' || travelState.vehicleType === 'scooter') && travelState.health <= 0) {
                endTravel(false, 'Your ' + travelState.vehicleType + ' broke down!');
                return;
            }

            if ((travelState.vehicleType === 'car' || travelState.vehicleType === 'truck') && travelState.fuel <= 0) {
                endTravel(false, 'Your ' + travelState.vehicleType + ' ran out of fuel!');
                return;
            }

            renderTravel();
        }

        function endTravel(success, reason = '') {
            clearInterval(travelState.gameLoop);
            travelState.active = false;

            const elapsedSec = (Date.now() - travelState.startTime) / 1000;
            const wpm = travelState.wordsTyped > 0 ? Math.round((travelState.wordsTyped / elapsedSec) * 60) : 0;
            const accuracy = travelState.totalChars > 0 ? Math.round((travelState.correctChars / travelState.totalChars) * 100) : 0;

            // Save vehicle state
            const vehicle = state.vehicles[travelState.vehicleType];
            if (travelState.vehicleType === 'bike' || travelState.vehicleType === 'scooter') {
                vehicle.health = Math.max(0, travelState.health);
            } else {
                vehicle.fuel = Math.max(0, travelState.fuel);
            }

            if (success) {
                state.location = travelState.destination;
                const bonus = Math.floor(travelState.score / 5);
                addCoins(bonus);
                action(`üéâ Arrived at ${state.locations[travelState.destination].name}!`, 'success');
                action(`üí∞ Bonus: ${bonus}¬¢ for your performance!`, 'success');

                // Repair/refuel at home
                if (travelState.destination === 'home') {
                    for (const [vName, vData] of Object.entries(state.vehicles)) {
                        if (vData.owned) {
                            if (vName === 'bike' || vName === 'scooter') {
                                if ((vData.health || 100) < 100) {
                                    vData.health = 100;
                                    action(`üîß ${vData.emoji} ${vName} repaired!`, 'success');
                                }
                            } else {
                                if ((vData.fuel || 100) < 100) {
                                    vData.fuel = 100;
                                    action(`‚õΩ ${vData.emoji} ${vName} refueled!`, 'success');
                                }
                            }
                        }
                    }
                }
            } else {
                action(`üíî ${reason}`, 'error');
                action(`üìç Stranded! Walking back home...`, 'warning');
                state.location = 'home';
                // Repair/refuel at home after walking back
                for (const [vName, vData] of Object.entries(state.vehicles)) {
                    if (vData.owned) {
                        if (vName === 'bike' || vName === 'scooter') {
                            vData.health = 100;
                        } else {
                            vData.fuel = 100;
                        }
                    }
                }
                action(`üîß All vehicles repaired at home`, 'system');
            }

            save();

            // Show results
            display(`<span class="section-title">‚ïê‚ïê‚ïê üèÅ TRIP ${success ? 'COMPLETE' : 'FAILED'} ‚ïê‚ïê‚ïê</span>

${success ? `<span class="green">‚úì Arrived at ${state.locations[travelState.destination].name}!</span>` : `<span class="red">‚úó ${reason}</span>`}

<span class="highlight">TRIP STATS</span>
  Score:      <span class="highlight">${travelState.score}</span> pts
  Distance:   ${Math.floor(travelState.distance)}/${travelState.totalDistance}

<span class="highlight">TYPING STATS</span>
  WPM:        <span class="cyan">${wpm}</span>
  Accuracy:   <span class="${accuracy >= 80 ? 'green' : accuracy >= 50 ? 'highlight' : 'red'}">${accuracy}%</span>
  Words:      ${travelState.wordsTyped}
  Perfect:    ${travelState.perfectWords}
  Errors:     <span class="red">${travelState.errors}</span>
  Idle Time:  ${(travelState.idleTime / 1000).toFixed(1)}s

<span class="dim">Type 'location' to see your current position</span>`);
        }

        function renderTravel() {
            const vehicle = state.vehicles[travelState.vehicleType];
            const vEmoji = vehicle.emoji;

            // Calculate stats
            const elapsedSec = Math.max(0.1, (Date.now() - travelState.startTime) / 1000);
            const wpm = Math.round((travelState.wordsTyped / elapsedSec) * 60);
            const accuracy = travelState.totalChars > 0 ? Math.round((travelState.correctChars / travelState.totalChars) * 100) : 100;
            const idleSec = ((Date.now() - travelState.lastKeyTime) / 1000).toFixed(1);

            // Progress bar
            const progress = Math.min(100, (travelState.distance / travelState.totalDistance) * 100);
            const progBars = Math.floor(progress / 5);
            const progressBar = `[${'‚ñà'.repeat(progBars)}${'‚ñë'.repeat(20-progBars)}] ${Math.floor(progress)}%`;

            // Health/Fuel bar
            let statusBar = '';
            if (travelState.vehicleType === 'bike' || travelState.vehicleType === 'scooter') {
                const h = Math.max(0, travelState.health);
                const hBars = Math.floor(h / 10);
                statusBar = `‚ù§Ô∏è [${'<span class="red">‚ñà</span>'.repeat(hBars)}${'‚ñë'.repeat(10-hBars)}] ${h}%`;
            } else {
                const f = Math.max(0, travelState.fuel);
                const fBars = Math.floor(f / 10);
                statusBar = `‚õΩ [${'<span class="highlight">‚ñà</span>'.repeat(fBars)}${'‚ñë'.repeat(10-fBars)}] ${f}%`;
            }

            // Build road with obstacles
            let road = '';
            for (let y = 0; y < 10; y++) {
                let row = '  ‚îÇ';
                for (let lane = 0; lane < 5; lane++) {
                    const obstacle = travelState.obstacles.find(o => o.lane === lane && Math.floor(o.y) === y);
                    if (y === 8 && lane === travelState.position) {
                        row += ` ${vEmoji} `;
                    } else if (obstacle) {
                        row += ` ${obstacle.emoji} `;
                    } else {
                        row += ' ¬∑ ';
                    }
                }
                row += '‚îÇ';
                road += row + '\n';
            }

            display(`<span class="section-title">‚ïê‚ïê‚ïê ${vEmoji} TRAVELING TO ${state.locations[travelState.destination].emoji} ${state.locations[travelState.destination].name.toUpperCase()} ‚ïê‚ïê‚ïê</span>

${progressBar}   Score: <span class="highlight">${travelState.score}</span>
${statusBar}

<span class="dim">  ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó</span>
${road}<span class="dim">  ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù</span>

<span class="highlight">TYPE:</span> <span class="green">${travelState.currentDirection}</span>

<span class="dim">‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ LIVE STATS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span>
  WPM: <span class="cyan">${wpm}</span>  ‚îÇ  Accuracy: <span class="${accuracy >= 80 ? 'green' : 'red'}">${accuracy}%</span>  ‚îÇ  Idle: <span class="${parseFloat(idleSec) > 2 ? 'red' : 'dim'}">${idleSec}s</span>
  Perfect: <span class="green">${travelState.perfectWords}</span>  ‚îÇ  Errors: <span class="red">${travelState.errors}</span>  ‚îÇ  Words: ${travelState.wordsTyped}
<span class="dim">‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span>`);
        }

        // ==================== INIT ====================
        function init() {
            load();
            updateStats();

            const inputEl = document.getElementById('input');

            // Update prediction on every keystroke
            inputEl.addEventListener('input', (e) => {
                updatePrediction(e.target.value);
            });

            inputEl.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' && e.target.value.trim()) {
                    handleCommand(e.target.value);
                    e.target.value = '';
                    updatePrediction('');
                }
            });

            // Auto-refresh farm view every second
            setInterval(() => {
                const disp = document.getElementById('display');
                if (disp.innerHTML.includes('FARM') && !disp.innerHTML.includes('STATS')) {
                    showFarm();
                }
            }, 1000);

            action('üå± Welcome to TypeFarm!', 'success');
            action("Type 'help' to get started", 'system');
            showHelp();
        }

        init();
    </script>
</body>
</html>
