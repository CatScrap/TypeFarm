<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TypeFarm</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        :root {
            --bg-dark: #0a0a0f;
            --bg-panel: #12121a;
            --bg-input: #1a1a25;
            --text-primary: #e8e8e8;
            --text-dim: #888;
            --accent-cyan: #00d9ff;
            --accent-green: #00ff88;
            --accent-yellow: #ffd700;
            --accent-red: #ff4757;
            --accent-pink: #ff9ff3;
            --border: #2a2a3a;
        }

        body {
            font-family: 'Courier New', monospace;
            background: var(--bg-dark);
            color: var(--text-primary);
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .header {
            background: var(--bg-panel);
            border-bottom: 1px solid var(--border);
            padding: 0.8rem 2rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .header h1 {
            font-size: 1.5rem;
            background: linear-gradient(90deg, var(--accent-cyan), var(--accent-green));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .stats {
            display: flex;
            gap: 1.5rem;
            font-size: 0.9rem;
        }

        .stat span { color: var(--accent-yellow); }

        .main-content {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        .terminal-log {
            width: 35%;
            background: var(--bg-panel);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
        }

        .panel-header {
            padding: 0.5rem 1rem;
            background: var(--bg-input);
            border-bottom: 1px solid var(--border);
            font-size: 0.8rem;
            color: var(--accent-cyan);
        }

        .terminal-log-content {
            flex: 1;
            overflow-y: auto;
            padding: 0.8rem;
            font-size: 0.8rem;
            line-height: 1.5;
        }

        .log-entry { margin-bottom: 0.3rem; }
        .log-system { color: var(--accent-cyan); }
        .log-success { color: var(--accent-green); }
        .log-warning { color: var(--accent-yellow); }
        .log-error { color: var(--accent-red); }
        .log-npc { color: var(--accent-pink); }

        .game-frame {
            width: 65%;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .game-content {
            flex: 1;
            overflow-y: auto;
            padding: 1rem;
            font-size: 0.9rem;
            line-height: 1.6;
            white-space: pre-wrap;
        }

        .terminal-input-bar {
            background: var(--bg-panel);
            border-top: 1px solid var(--border);
            padding: 0.8rem 1.5rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .terminal-prompt { color: var(--accent-green); }

        .terminal-input {
            flex: 1;
            background: transparent;
            border: none;
            font-family: inherit;
            font-size: 1rem;
            color: var(--text-primary);
            outline: none;
        }

        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: var(--bg-dark); }
        ::-webkit-scrollbar-thumb { background: var(--border); border-radius: 3px; }

        .typing-area {
            background: var(--bg-input);
            border: 1px solid var(--border);
            padding: 1rem;
            margin: 1rem 0;
            border-radius: 4px;
            font-size: 1.1rem;
            line-height: 1.8;
        }

        .correct { color: var(--accent-green); }
        .incorrect { color: var(--accent-red); background: rgba(255,71,87,0.2); }
        .cursor { border-left: 2px solid var(--accent-cyan); animation: blink 1s infinite; }
        .pending { color: var(--text-dim); }

        @keyframes blink { 50% { border-color: transparent; } }

        .section-title { color: var(--accent-cyan); margin-bottom: 0.5rem; }
        .highlight { color: var(--accent-yellow); }
        .dim { color: var(--text-dim); }
        .green { color: var(--accent-green); }
        .red { color: var(--accent-red); }
        .pink { color: var(--accent-pink); }
    </style>
</head>
<body>
    <header class="header">
        <h1>üå± TypeFarm</h1>
        <div class="stats">
            <div>Coins: <span id="coins">0</span></div>
            <div>Level: <span id="level">1</span></div>
            <div>WPM: <span id="wpm">0</span></div>
            <div>Accuracy: <span id="accuracy">100%</span></div>
        </div>
    </header>

    <main class="main-content">
        <aside class="terminal-log">
            <div class="panel-header">üìü Terminal Log</div>
            <div class="terminal-log-content" id="log"></div>
        </aside>

        <section class="game-frame">
            <div class="panel-header">üì∫ Display</div>
            <div class="game-content" id="display"></div>
        </section>
    </main>

    <footer class="terminal-input-bar">
        <span class="terminal-prompt">$</span>
        <input type="text" class="terminal-input" id="input" placeholder="Type 'help' for commands..." autocomplete="off" autofocus>
    </footer>

    <script>
        // ==================== GAME STATE ====================
        const state = {
            coins: 50,
            level: 1,
            xp: 0,
            totalKeystrokes: 0,
            correctKeystrokes: 0,
            startTime: null,
            mode: 'normal', // 'normal' or 'typing'
            typingText: '',
            typingIndex: 0,
            inventory: {},
            farm: Array(9).fill(null), // 3x3 grid: A1-A3, B1-B3, C1-C3
            shopItems: {
                'carrot seeds': { price: 10, desc: 'Grows in 30s, sells for 25' },
                'tomato seeds': { price: 20, desc: 'Grows in 45s, sells for 50' },
                'corn seeds': { price: 35, desc: 'Grows in 60s, sells for 80' },
                'pumpkin seeds': { price: 50, desc: 'Grows in 90s, sells for 120' },
                'golden seeds': { price: 150, desc: 'Grows in 120s, sells for 400' },
                'fertilizer': { price: 25, desc: 'Halves remaining grow time' },
                'watering can': { price: 100, desc: 'Auto-waters all crops' }
            },
            crops: {
                'carrot seeds': { growTime: 30, emoji: 'ü•ï', sellPrice: 25, stages: ['üå±', 'üåø', 'ü•ï'] },
                'tomato seeds': { growTime: 45, emoji: 'üçÖ', sellPrice: 50, stages: ['üå±', 'üåø', 'üçÖ'] },
                'corn seeds': { growTime: 60, emoji: 'üåΩ', sellPrice: 80, stages: ['üå±', 'üåæ', 'üåΩ'] },
                'pumpkin seeds': { growTime: 90, emoji: 'üéÉ', sellPrice: 120, stages: ['üå±', 'üåø', 'üéÉ'] },
                'golden seeds': { growTime: 120, emoji: '‚ú®', sellPrice: 400, stages: ['üå±', 'üí´', '‚ú®'] }
            },
            prompts: [
                "The quick brown fox jumps over the lazy dog.",
                "Pack my box with five dozen liquor jugs.",
                "Farmers plant seeds in fertile soil every spring.",
                "The harvest moon rises over golden wheat fields.",
                "Water your crops daily for the best results.",
                "Typing faster earns more coins for your farm.",
                "Buy seeds from the shop and watch them grow.",
                "A good farmer knows patience is a virtue.",
                "The scarecrow guards the field from hungry crows.",
                "Fresh vegetables taste better from your own garden."
            ]
        };

        const plotNames = ['A1', 'A2', 'A3', 'B1', 'B2', 'B3', 'C1', 'C2', 'C3'];

        // ==================== UTILITIES ====================
        function save() { localStorage.setItem('typefarm', JSON.stringify(state)); }

        function load() {
            const saved = localStorage.getItem('typefarm');
            if (saved) {
                const data = JSON.parse(saved);
                Object.assign(state, data);
            }
        }

        function log(msg, type = 'system') {
            const el = document.getElementById('log');
            const entry = document.createElement('div');
            entry.className = `log-entry log-${type}`;
            entry.textContent = msg;
            el.appendChild(entry);
            el.scrollTop = el.scrollHeight;
        }

        function display(content) {
            document.getElementById('display').innerHTML = content;
        }

        function updateStats() {
            document.getElementById('coins').textContent = state.coins;
            document.getElementById('level').textContent = state.level;
            if (state.totalKeystrokes > 0) {
                const acc = Math.round((state.correctKeystrokes / state.totalKeystrokes) * 100);
                document.getElementById('accuracy').textContent = acc + '%';
            }
            if (state.startTime && state.correctKeystrokes > 0) {
                const mins = (Date.now() - state.startTime) / 60000;
                document.getElementById('wpm').textContent = Math.round((state.correctKeystrokes / 5) / mins);
            }
        }

        function addCoins(n) {
            state.coins += n;
            state.xp += n;
            if (state.xp >= state.level * 100) {
                state.level++;
                log(`üéâ LEVEL UP! Now level ${state.level}!`, 'success');
            }
            updateStats();
            save();
        }

        function getPlotIndex(name) {
            return plotNames.indexOf(name.toUpperCase());
        }

        // ==================== DISPLAY FUNCTIONS ====================
        function showHelp() {
            display(`<span class="section-title">‚ïê‚ïê‚ïê COMMANDS ‚ïê‚ïê‚ïê</span>

<span class="highlight">GENERAL</span>
  help              - Show this help
  stats             - Show your stats
  clear             - Clear terminal log

<span class="highlight">TYPING</span>
  type              - Start typing challenge
  (just type when in typing mode, 'exit' to leave)

<span class="highlight">SHOP</span>
  shop              - View shop items
  shop buy [item]   - Buy an item
  shop sell [item] [qty] - Sell harvested crops

<span class="highlight">FARM</span>
  farm              - View your farm
  farm plant [seed] [plot] - Plant seeds (e.g., farm plant carrot A1)
  farm water [plot] - Water a plot
  farm fertilize [plot] - Use fertilizer
  farm harvest [plot] - Harvest ready crops

<span class="highlight">INVENTORY</span>
  inventory         - View your items
  inv               - Shortcut for inventory

<span class="dim">Plots are named A1-A3, B1-B3, C1-C3</span>`);
        }

        function showShop() {
            let html = `<span class="section-title">‚ïê‚ïê‚ïê üè™ FARMER JOE'S SHOP ‚ïê‚ïê‚ïê</span>

<span class="pink">"Welcome! What can I get ya today?"</span>

<span class="highlight">SEEDS</span>
`;
            for (const [name, item] of Object.entries(state.shopItems)) {
                if (name.includes('seeds')) {
                    html += `  ${name.padEnd(16)} - <span class="highlight">${item.price}</span> coins  <span class="dim">${item.desc}</span>\n`;
                }
            }
            html += `\n<span class="highlight">TOOLS</span>\n`;
            for (const [name, item] of Object.entries(state.shopItems)) {
                if (!name.includes('seeds')) {
                    html += `  ${name.padEnd(16)} - <span class="highlight">${item.price}</span> coins  <span class="dim">${item.desc}</span>\n`;
                }
            }
            html += `\n<span class="dim">Use: shop buy [item name]</span>`;
            html += `\n<span class="dim">Your coins: </span><span class="highlight">${state.coins}</span>`;
            display(html);
        }

        function showFarm() {
            let html = `<span class="section-title">‚ïê‚ïê‚ïê üåæ YOUR FARM ‚ïê‚ïê‚ïê</span>\n\n`;

            // 3x3 grid
            for (let row = 0; row < 3; row++) {
                const rowLetter = ['A', 'B', 'C'][row];
                let rowDisplay = '  ';
                for (let col = 0; col < 3; col++) {
                    const idx = row * 3 + col;
                    const plot = state.farm[idx];
                    const plotName = `${rowLetter}${col + 1}`;

                    let cell = '[ üü´ ]';
                    if (plot) {
                        const elapsed = (Date.now() - plot.plantedAt) / 1000;
                        const progress = Math.min(elapsed / plot.growTime, 1);
                        const crop = state.crops[plot.type];

                        if (progress >= 1) {
                            cell = `[${crop.emoji}RDY]`;
                        } else {
                            const stageIdx = Math.floor(progress * 2);
                            const remaining = Math.ceil(plot.growTime - elapsed);
                            cell = `[${crop.stages[stageIdx]}${remaining.toString().padStart(3)}]`;
                        }
                    }
                    rowDisplay += ` ${plotName}${cell}`;
                }
                html += rowDisplay + '\n';
            }

            html += `\n<span class="dim">Legend: üü´=Empty, üå±=Growing, RDY=Ready to harvest</span>`;
            html += `\n<span class="dim">Use: farm plant [seed] [plot], farm harvest [plot]</span>`;
            display(html);
        }

        function showInventory() {
            let html = `<span class="section-title">‚ïê‚ïê‚ïê üéí INVENTORY ‚ïê‚ïê‚ïê</span>\n\n`;

            const items = Object.entries(state.inventory).filter(([k, v]) => v > 0);

            if (items.length === 0) {
                html += `<span class="dim">Your inventory is empty.</span>\n`;
                html += `<span class="dim">Buy seeds from the shop to get started!</span>`;
            } else {
                for (const [name, count] of items) {
                    html += `  ${name.padEnd(20)} x${count}\n`;
                }
            }

            html += `\n<span class="dim">Use: shop sell [item] [quantity]</span>`;
            display(html);
        }

        function showStats() {
            display(`<span class="section-title">‚ïê‚ïê‚ïê üìä YOUR STATS ‚ïê‚ïê‚ïê</span>

  Level:      <span class="highlight">${state.level}</span>
  XP:         <span class="highlight">${state.xp}</span> / ${state.level * 100}
  Coins:      <span class="highlight">${state.coins}</span>

  Keystrokes: ${state.totalKeystrokes}
  Correct:    ${state.correctKeystrokes}
  Accuracy:   ${state.totalKeystrokes > 0 ? Math.round((state.correctKeystrokes / state.totalKeystrokes) * 100) : 100}%`);
        }

        function showTyping() {
            state.mode = 'typing';
            state.typingText = state.prompts[Math.floor(Math.random() * state.prompts.length)];
            state.typingIndex = 0;
            renderTyping();
            log('üìù Typing mode started. Type the text! (type "exit" to quit)', 'system');
        }

        function renderTyping() {
            let html = `<span class="section-title">‚ïê‚ïê‚ïê ‚å®Ô∏è TYPING CHALLENGE ‚ïê‚ïê‚ïê</span>

<span class="dim">Type the text below. Earn ${state.level} coin(s) per correct character!</span>

<div class="typing-area">`;

            for (let i = 0; i < state.typingText.length; i++) {
                if (i < state.typingIndex) {
                    html += `<span class="correct">${state.typingText[i]}</span>`;
                } else if (i === state.typingIndex) {
                    html += `<span class="cursor">${state.typingText[i]}</span>`;
                } else {
                    html += `<span class="pending">${state.typingText[i]}</span>`;
                }
            }

            html += `</div>

<span class="dim">Progress: ${state.typingIndex}/${state.typingText.length}</span>
<span class="dim">Type 'exit' to leave typing mode</span>`;

            display(html);
        }

        // ==================== COMMANDS ====================
        function handleCommand(input) {
            const raw = input.trim();
            const parts = raw.toLowerCase().split(/\s+/);
            const cmd = parts[0];

            // Typing mode
            if (state.mode === 'typing') {
                if (raw.toLowerCase() === 'exit') {
                    state.mode = 'normal';
                    log('üëã Left typing mode', 'system');
                    showHelp();
                    return;
                }
                handleTypingInput(raw);
                return;
            }

            // Normal commands
            switch (cmd) {
                case 'help':
                case '?':
                    showHelp();
                    break;

                case 'type':
                case 'typing':
                    showTyping();
                    break;

                case 'shop':
                    handleShopCommand(parts);
                    break;

                case 'farm':
                    handleFarmCommand(parts);
                    break;

                case 'inventory':
                case 'inv':
                case 'i':
                    showInventory();
                    break;

                case 'stats':
                    showStats();
                    break;

                case 'clear':
                    document.getElementById('log').innerHTML = '';
                    log('üßπ Log cleared', 'system');
                    break;

                case 'save':
                    save();
                    log('üíæ Game saved!', 'success');
                    break;

                default:
                    log(`‚ùì Unknown command: ${cmd}. Type 'help' for commands.`, 'warning');
            }
        }

        function handleShopCommand(parts) {
            if (parts.length === 1) {
                showShop();
                return;
            }

            const action = parts[1];

            if (action === 'buy') {
                const itemName = parts.slice(2).join(' ');
                const item = state.shopItems[itemName];

                if (!item) {
                    log(`‚ùå Unknown item: ${itemName}`, 'error');
                    return;
                }

                if (state.coins < item.price) {
                    log(`‚ùå Not enough coins! Need ${item.price}, have ${state.coins}`, 'error');
                    return;
                }

                state.coins -= item.price;
                state.inventory[itemName] = (state.inventory[itemName] || 0) + 1;
                log(`‚úÖ Bought ${itemName} for ${item.price} coins`, 'success');
                updateStats();
                save();
                showShop();
            }
            else if (action === 'sell') {
                const qty = parseInt(parts[parts.length - 1]) || 1;
                const itemName = parts.slice(2, parts.length - (parseInt(parts[parts.length - 1]) ? 1 : 0)).join(' ');

                if (!state.inventory[itemName] || state.inventory[itemName] < qty) {
                    log(`‚ùå You don't have ${qty}x ${itemName}`, 'error');
                    return;
                }

                // Find sell price
                let sellPrice = 0;
                for (const [seedName, crop] of Object.entries(state.crops)) {
                    if (itemName === crop.emoji || itemName.includes(seedName.replace(' seeds', ''))) {
                        sellPrice = crop.sellPrice;
                        break;
                    }
                }

                // Check harvested items
                const harvestPrices = {
                    'carrot': 25, 'tomato': 50, 'corn': 80, 'pumpkin': 120, 'golden': 400
                };
                for (const [name, price] of Object.entries(harvestPrices)) {
                    if (itemName.includes(name)) {
                        sellPrice = price;
                        break;
                    }
                }

                if (sellPrice === 0) {
                    log(`‚ùå Can't sell ${itemName}`, 'error');
                    return;
                }

                state.inventory[itemName] -= qty;
                const total = sellPrice * qty;
                addCoins(total);
                log(`üí∞ Sold ${qty}x ${itemName} for ${total} coins!`, 'success');
                showInventory();
            }
        }

        function handleFarmCommand(parts) {
            if (parts.length === 1) {
                showFarm();
                return;
            }

            const action = parts[1];

            if (action === 'plant') {
                const plotName = parts[parts.length - 1].toUpperCase();
                const seedName = parts.slice(2, -1).join(' ');
                const plotIdx = getPlotIndex(plotName);

                if (plotIdx === -1) {
                    log(`‚ùå Invalid plot: ${plotName}. Use A1-C3.`, 'error');
                    return;
                }

                if (state.farm[plotIdx]) {
                    log(`‚ùå Plot ${plotName} is not empty!`, 'error');
                    return;
                }

                const fullSeedName = seedName.includes('seeds') ? seedName : seedName + ' seeds';

                if (!state.inventory[fullSeedName] || state.inventory[fullSeedName] < 1) {
                    log(`‚ùå No ${fullSeedName} in inventory!`, 'error');
                    return;
                }

                if (!state.crops[fullSeedName]) {
                    log(`‚ùå Unknown seed type: ${fullSeedName}`, 'error');
                    return;
                }

                state.inventory[fullSeedName]--;
                state.farm[plotIdx] = {
                    type: fullSeedName,
                    plantedAt: Date.now(),
                    growTime: state.crops[fullSeedName].growTime,
                    watered: false
                };
                log(`üå± Planted ${fullSeedName} in plot ${plotName}!`, 'success');
                save();
                showFarm();
            }
            else if (action === 'water') {
                const plotName = parts[2]?.toUpperCase();
                const plotIdx = getPlotIndex(plotName);

                if (plotIdx === -1) {
                    log(`‚ùå Invalid plot: ${plotName}`, 'error');
                    return;
                }

                if (!state.farm[plotIdx]) {
                    log(`‚ùå Nothing planted in ${plotName}!`, 'error');
                    return;
                }

                if (!state.farm[plotIdx].watered) {
                    state.farm[plotIdx].watered = true;
                    state.farm[plotIdx].growTime *= 0.8; // 20% faster
                    log(`üíß Watered plot ${plotName}! Growth speed +20%`, 'success');
                    save();
                } else {
                    log(`üíß Plot ${plotName} already watered!`, 'warning');
                }
                showFarm();
            }
            else if (action === 'fertilize') {
                const plotName = parts[2]?.toUpperCase();
                const plotIdx = getPlotIndex(plotName);

                if (plotIdx === -1) {
                    log(`‚ùå Invalid plot: ${plotName}`, 'error');
                    return;
                }

                if (!state.farm[plotIdx]) {
                    log(`‚ùå Nothing planted in ${plotName}!`, 'error');
                    return;
                }

                if (!state.inventory['fertilizer'] || state.inventory['fertilizer'] < 1) {
                    log(`‚ùå No fertilizer! Buy from shop.`, 'error');
                    return;
                }

                state.inventory['fertilizer']--;
                const elapsed = (Date.now() - state.farm[plotIdx].plantedAt) / 1000;
                const remaining = state.farm[plotIdx].growTime - elapsed;
                state.farm[plotIdx].growTime -= remaining / 2;
                log(`üß™ Fertilized ${plotName}! Remaining time halved!`, 'success');
                save();
                showFarm();
            }
            else if (action === 'harvest') {
                const plotName = parts[2]?.toUpperCase();
                const plotIdx = getPlotIndex(plotName);

                if (plotIdx === -1) {
                    log(`‚ùå Invalid plot: ${plotName}`, 'error');
                    return;
                }

                if (!state.farm[plotIdx]) {
                    log(`‚ùå Nothing to harvest in ${plotName}!`, 'error');
                    return;
                }

                const plot = state.farm[plotIdx];
                const elapsed = (Date.now() - plot.plantedAt) / 1000;

                if (elapsed < plot.growTime) {
                    const remaining = Math.ceil(plot.growTime - elapsed);
                    log(`‚ùå Not ready! ${remaining}s remaining.`, 'error');
                    return;
                }

                const crop = state.crops[plot.type];
                const cropName = plot.type.replace(' seeds', '');
                state.inventory[cropName] = (state.inventory[cropName] || 0) + 1;
                state.farm[plotIdx] = null;
                log(`üåæ Harvested ${crop.emoji} ${cropName} from ${plotName}!`, 'success');
                log(`üí° Use 'shop sell ${cropName} 1' to sell for ${crop.sellPrice} coins`, 'system');
                save();
                showFarm();
            }
        }

        function handleTypingInput(input) {
            if (!state.startTime) state.startTime = Date.now();

            for (const char of input) {
                if (state.typingIndex >= state.typingText.length) break;

                state.totalKeystrokes++;
                const expected = state.typingText[state.typingIndex];

                if (char === expected) {
                    state.correctKeystrokes++;
                    state.typingIndex++;
                    addCoins(state.level);
                }
            }

            if (state.typingIndex >= state.typingText.length) {
                log(`‚úÖ Completed! Bonus: +${state.level * 10} coins!`, 'success');
                addCoins(state.level * 10);
                state.typingText = state.prompts[Math.floor(Math.random() * state.prompts.length)];
                state.typingIndex = 0;
            }

            updateStats();
            renderTyping();
        }

        // ==================== INIT ====================
        function init() {
            load();
            updateStats();

            document.getElementById('input').addEventListener('keypress', (e) => {
                if (e.key === 'Enter' && e.target.value.trim()) {
                    handleCommand(e.target.value);
                    e.target.value = '';
                }
            });

            // Auto-refresh farm view
            setInterval(() => {
                const display = document.getElementById('display');
                if (display.innerHTML.includes('YOUR FARM')) {
                    showFarm();
                }
            }, 1000);

            log('üå± Welcome to TypeFarm!', 'success');
            log("Type 'help' to see commands", 'system');
            showHelp();
        }

        init();
    </script>
</body>
</html>
